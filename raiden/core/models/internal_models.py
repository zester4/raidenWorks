import uuid
from datetime import datetime
from typing import List, Dict, Any, Optional, Literal
from pydantic import BaseModel, Field, validator, HttpUrl

from raiden.core.constants import (
    ActionType,
    SessionStatus,
    SESSION_STATUS_INITIALIZING,
    ACTION_TYPE_NAVIGATE,
    ACTION_TYPE_CLICK,
    ACTION_TYPE_TYPE,
    ACTION_TYPE_SCROLL,
    ACTION_TYPE_EXTRACT_TEXT,
    ACTION_TYPE_ASK_USER,
)

class ActionStep(BaseModel):
    step_id: int = Field(..., description="Sequential identifier for the step within the plan.")
    action_type: ActionType = Field(..., description="The type of browser action to perform.")
    selector: Optional[str] = Field(default=None, description="CSS or XPath selector for targeting a DOM element.")
    target_url: Optional[HttpUrl] = Field(default=None, description="URL for navigation actions.")
    text_to_type: Optional[str] = Field(default=None, description="Text to be typed into an element.")
    prompt_to_user: Optional[str] = Field(default=None, description="Prompt text for 'ask_user' action.")
    extraction_variable: Optional[str] = Field(default=None, description="Variable name to store extracted text.")
    human_readable_reasoning: Optional[str] = Field(default=None, description="Human-readable explanation of the step's purpose.")

    @validator('target_url', pre=True, always=True)
    def check_target_url_for_navigate(cls, v, values):
        if values.get('action_type') == ACTION_TYPE_NAVIGATE and v is None:
            raise ValueError("target_url is required for 'navigate' action_type")
        return v

    @validator('text_to_type', pre=True, always=True)
    def check_text_for_type(cls, v, values):
        if values.get('action_type') == ACTION_TYPE_TYPE and v is None:
            raise ValueError("text_to_type is required for 'type' action_type")
        return v

    @validator('extraction_variable', pre=True, always=True)
    def check_extraction_variable_for_extract(cls, v, values):
        if values.get('action_type') == ACTION_TYPE_EXTRACT_TEXT and v is None:
            raise ValueError("extraction_variable is required for 'extract_text' action_type")
        return v

class Plan(BaseModel):
    steps: List[ActionStep] = Field(..., description="Ordered list of actions to be executed.")

    @validator('steps')
    def check_step_ids_sequential(cls, steps: List[ActionStep]):
        for i, step in enumerate(steps):
            if step.step_id != i:
                raise ValueError(f"Step IDs must be sequential starting from 0. Found step_id {step.step_id} at index {i}.")
        return steps

class SessionState(BaseModel):
    session_id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique identifier for the session.")
    status: SessionStatus = Field(default=SESSION_STATUS_INITIALIZING, description="Current status of the session.")
    user_prompt: str = Field(..., description="The original natural language prompt from the user.")
    plan: Optional[Plan] = Field(default=None, description="The execution plan generated by the Planning Service.")
    current_step_index: int = Field(default=0, description="Index of the next step in the plan to be executed.")
    session_variables: Dict[str, Any] = Field(default_factory=dict, description="Data extracted or generated during the session.")
    created_at: datetime = Field(default_factory=datetime.utcnow, description="Timestamp when the session was created (UTC).")
    updated_at: datetime = Field(default_factory=datetime.utcnow, description="Timestamp when the session state was last updated (UTC).")
    session_config: Optional[Dict[str, Any]] = Field(
        default=None, 
        description="Snapshot of session-specific configuration (e.g., headless, use_vision)."
    )
    last_error: Optional[str] = Field(default=None, description="Details of the last error encountered, if status is FAILED.")
    ask_user_prompt: Optional[str] = Field(default=None, description="The question currently waiting for user input, if status is PAUSED_ASK_USER.")
    final_result: Optional[Any] = Field(default=None, description="The final result or output of the completed session.")

    class Config:
        extra = 'forbid'
        validate_assignment = True
